<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Map with Leaflet</title>

    <!-- Include Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>
    <!-- Include Leaflet JavaScript -->
    <!-- Make sure you put this AFTER Leaflet's CSS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>
            <script src="{{ url_for('static', filename='js/heatmap.min.js') }}"></script>
            <script src="{{ url_for('static', filename='js/leaflet-heatmap.js') }}"></script>

    <!--    data-->
    <script src="{{ url_for('static', filename='js/data.js') }}"></script>

    <link rel="stylesheet" href="{{ url_for('static', filename='css/user-dashboard.css') }}">
    <style>
        /* Set the size of the body to take up the full screen */
        body {
            margin: 0;
            height: 100vh;
            width: 70%;
            display: flex;
        }
    </style>
</head>
<body>
<div id="container">
    <div id="map"></div>
</div>

<script>

    var cfg = {
        // radius should be small ONLY if scaleRadius is true (or small radius is intended)
        // if scaleRadius is false it will be the constant radius used in pixels
        "radius": 2,
        "maxOpacity": .8,
        // scales the radius based on map zoom
        "scaleRadius": true,
        // if set to false the heatmap uses the global maximum for colorization
        // if activated: uses the data maximum within the current map boundaries
        //   (there will always be a red spot with useLocalExtremas true)
        // "useLocalExtrema": true,
        // which field name in your data represents the latitude - default "lat"
        latField: 'latitude',
        // which field name in your data represents the longitude - default "lng"
        lngField: 'longitude',
        // which field name in your data represents the data value - default "value"
        valueField: 'humidity'
    };


    var heatmapLayer = new HeatmapOverlay(cfg);
    heatmapLayer.setData(el_nimo_data);

    var baseLayer = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 15,
        attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
    });

    var map = new L.Map('map', {
        center: new L.LatLng(0, -160),
        zoom: 4,
        layers: [baseLayer, heatmapLayer]
    });

    function updateLatLong() {
        const center = map.getCenter();
        document.getElementById('latitude').value = center.lat;
        document.getElementById('longitude').value = center.lng;
    }
    map.on('move', updateLatLong);
</script>

<div id="data-visualization">
    <iframe src="{{ url_for('data_visualization') }}" frameborder="0" style="width: 300%; height: 600px;"></iframe>
</div>

<div id="filter-visualization">
    <iframe src="{{ url_for('get_monthly_data', year=94, month=8) }}" frameborder="0"></iframe>
</div>

</body>
</html>